<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂúìÁöÑÂü∫Êú¨ÊÄßË≥™Â∞èÊ∏¨È©ó Circle Geometry Quiz</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f9ff;
        }
        .diagram-container svg {
            filter: drop-shadow(0 4px 3px rgb(0 0 0 / 0.07));
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo } = React;

        // --- Geometry Helpers ---
        const CX = 100;
        const CY = 100;
        const R = 80;

        const getPt = (angleDeg) => {
            const angleRad = (angleDeg * Math.PI) / 180;
            return {
                x: CX + R * Math.cos(angleRad),
                y: CY + R * Math.sin(angleRad)
            };
        };

        // Updated getArcPath to correctly handle wrapping across 0 degrees for Clockwise arcs
        const getArcPath = (startAngle, endAngle, radius = R) => {
            const startRad = startAngle * Math.PI / 180;
            const endRad = endAngle * Math.PI / 180;
            
            const start = {
                x: CX + radius * Math.cos(startRad),
                y: CY + radius * Math.sin(startRad)
            };
            const end = {
                x: CX + radius * Math.cos(endRad),
                y: CY + radius * Math.sin(endRad)
            };
            
            // Calculate angular difference in Clockwise direction
            let diff = endAngle - startAngle;
            while (diff < 0) diff += 360;
            while (diff >= 360) diff -= 360;
            
            // Use large arc flag if diff > 180
            const largeArcFlag = diff > 180 ? 1 : 0;
            const sweepFlag = 1; // Always sweep Clockwise
            
            return `M ${start.x} ${start.y} A ${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.x} ${end.y}`;
        };

        const getVec = (p1, p2) => ({ x: p2.x - p1.x, y: p2.y - p1.y });
        const lenVec = (v) => Math.sqrt(v.x * v.x + v.y * v.y);
        const normVec = (v) => { const l = lenVec(v); return l === 0 ? {x:0,y:0} : { x: v.x / l, y: v.y / l }; };
        const addVec = (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y });
        const scaleVec = (v, s) => ({ x: v.x * s, y: v.y * s });
        
        // Calculate angle of vector p1->p2 in degrees (0-360)
        const getDeg = (p1, p2) => {
            const rad = Math.atan2(p2.y - p1.y, p2.x - p1.x);
            let deg = rad * 180 / Math.PI;
            if (deg < 0) deg += 360;
            return deg;
        };

        // Draw Right Angle Symbol perfectly fitting two lines from a corner
        const RightAngleMark = ({ p1, corner, p2, size = 10 }) => {
            const u1 = normVec(getVec(corner, p1));
            const u2 = normVec(getVec(corner, p2));
            const c1 = addVec(corner, scaleVec(u1, size));
            const c2 = addVec(corner, scaleVec(u2, size));
            const c3 = addVec(c1, scaleVec(u2, size)); 
            return <path d={`M ${c1.x} ${c1.y} L ${c3.x} ${c3.y} L ${c2.x} ${c2.y}`} fill="none" stroke="#ef4444" strokeWidth="2" />;
        };

        // Draw Angle Arc with optional label
        const AngleArc = ({ corner, startDeg, endDeg, r = 20, color = "#3b82f6", label = null, showArc = true }) => {
            const startRad = startDeg * Math.PI / 180;
            const endRad = endDeg * Math.PI / 180;
            
            const p1 = { x: corner.x + r * Math.cos(startRad), y: corner.y + r * Math.sin(startRad) };
            const p2 = { x: corner.x + r * Math.cos(endRad), y: corner.y + r * Math.sin(endRad) };
            
            // Calculate shortest path for interior angles (<= 180)
            let diff = endDeg - startDeg;
            while (diff <= -180) diff += 360;
            while (diff > 180) diff -= 360;

            const sweep = diff > 0 ? 1 : 0;
            const largeArc = 0;

            const midDeg = startDeg + diff / 2;
            const midRad = midDeg * Math.PI / 180;
            const labelR = r + 14;
            const labelPos = { x: corner.x + labelR * Math.cos(midRad), y: corner.y + labelR * Math.sin(midRad) };

            return (
                <>
                    {showArc && <path d={`M ${p1.x} ${p1.y} A ${r} ${r} 0 ${largeArc} ${sweep} ${p2.x} ${p2.y}`} fill="none" stroke={color} strokeWidth="2" />}
                    {label && <text x={labelPos.x} y={labelPos.y} fontSize="12" fill={color} textAnchor="middle" dominantBaseline="middle" fontWeight="bold">{label}</text>}
                </>
            );
        };

        // Draw Tick Mark on a line
        const TickMark = ({ p1, p2, count = 1, color="#ef4444" }) => {
            const mid = { x: (p1.x + p2.x)/2, y: (p1.y + p2.y)/2 };
            const v = getVec(p1, p2);
            const perp = normVec({ x: -v.y, y: v.x }); 
            
            const size = 5;
            const spacing = 4;
            
            const ticks = [];
            for(let i=0; i<count; i++) {
                const offset = (i - (count-1)/2) * spacing;
                const u = normVec(v);
                const pos = addVec(mid, scaleVec(u, offset));
                
                const t1 = addVec(pos, scaleVec(perp, size));
                const t2 = addVec(pos, scaleVec(perp, -size));
                ticks.push(<line key={i} x1={t1.x} y1={t1.y} x2={t2.x} y2={t2.y} stroke={color} strokeWidth="2" />);
            }
            return <>{ticks}</>;
        };

        const DiagramWrapper = ({ children, hideCircle = false, dottedCircle = false }) => (
            <div className="w-full max-w-[300px] aspect-square bg-white rounded-xl shadow-md flex items-center justify-center p-4 border border-slate-200 mx-auto mb-6">
                <svg viewBox="0 0 200 200" className="w-full h-full">
                    {!hideCircle && !dottedCircle && <circle cx={CX} cy={CY} r={R} fill="none" stroke="#334155" strokeWidth="2" />}
                    {(dottedCircle || hideCircle === 'dotted') && <circle cx={CX} cy={CY} r={R} fill="none" stroke="#cbd5e1" strokeWidth="1" strokeDasharray="4" />}
                    {!hideCircle && <circle cx={CX} cy={CY} r="2" fill="#334155" />}
                    {!hideCircle && <text x={CX + 5} y={CY + 5} fontSize="10" fill="#64748b">O</text>}
                    {children}
                </svg>
            </div>
        );

        // --- Diagram Components ---

        const DiagramChordProp = ({ type }) => {
            const yChord = 140;
            const dx = Math.sqrt(R*R - (yChord-CY)*(yChord-CY));
            const p1 = { x: CX - dx, y: yChord };
            const p2 = { x: CX + dx, y: yChord };
            const mid = { x: CX, y: yChord };
            const center = { x: CX, y: CY };

            return (
                <DiagramWrapper>
                    <line x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke="#334155" strokeWidth="2" />
                    {type === 'perp-bisect' && (
                        <>
                            <line x1={center.x} y1={center.y} x2={mid.x} y2={mid.y} stroke="#ef4444" strokeWidth="2" strokeDasharray="4" />
                            <RightAngleMark p1={p1} corner={mid} p2={center} />
                        </>
                    )}
                    {type === 'mid-perp' && (
                        <>
                            <line x1={center.x} y1={center.y} x2={mid.x} y2={mid.y} stroke="#3b82f6" strokeWidth="2" />
                            <TickMark p1={p1} p2={mid} color="#3b82f6" />
                            <TickMark p1={mid} p2={p2} color="#3b82f6" />
                        </>
                    )}
                    {type === 'perp-bisector-center' && (
                        <>
                            <line x1={CX} y1={40} x2={CX} y2={180} stroke="#ef4444" strokeWidth="2" />
                            <RightAngleMark p1={p1} corner={mid} p2={{x:CX, y:40}} />
                            <TickMark p1={p1} p2={mid} color="#334155" />
                            <TickMark p1={mid} p2={p2} color="#334155" />
                        </>
                    )}
                </DiagramWrapper>
            );
        };

        const DiagramChordDist = ({ type }) => {
            const y1 = 60; const dx1 = Math.sqrt(R*R - (y1-CY)*(y1-CY));
            const y2 = 140; const dx2 = Math.sqrt(R*R - (y2-CY)*(y2-CY));
            const c1a = {x:CX-dx1, y:y1}, c1b = {x:CX+dx1, y:y1};
            const c2a = {x:CX-dx2, y:y2}, c2b = {x:CX+dx2, y:y2};
            const highlightChords = true; 
            
            return (
                <DiagramWrapper>
                    <line x1={c1a.x} y1={c1a.y} x2={c1b.x} y2={c1b.y} stroke={highlightChords ? "#ef4444" : "#334155"} strokeWidth="2" />
                    <line x1={c2a.x} y1={c2a.y} x2={c2b.x} y2={c2b.y} stroke={highlightChords ? "#ef4444" : "#334155"} strokeWidth="2" />
                    <line x1={CX} y1={CY} x2={CX} y2={y1} stroke="#94a3b8" strokeWidth="2" />
                    <line x1={CX} y1={CY} x2={CX} y2={y2} stroke="#94a3b8" strokeWidth="2" />
                    <RightAngleMark p1={c1b} corner={{x:CX,y:y1}} p2={{x:CX,y:CY}} size={6} />
                    <RightAngleMark p1={c2b} corner={{x:CX,y:y2}} p2={{x:CX,y:CY}} size={6} />
                    {type === 'eq-chord-eq-dist' && (
                        <>
                            <TickMark p1={{x:c1a.x+30, y:c1a.y}} p2={{x:c1b.x+30, y:c1b.y}} count={2} color="#ef4444" />
                            <TickMark p1={{x:c2a.x+30, y:c2a.y}} p2={{x:c2b.x+30, y:c2b.y}} count={2} color="#ef4444" />
                        </>
                    )}
                    {type === 'eq-dist-eq-chord' && (
                        <>
                            <TickMark p1={{x:CX,y:CY}} p2={{x:CX,y:y1}} count={1} color="#ef4444" />
                            <TickMark p1={{x:CX,y:CY}} p2={{x:CX,y:y2}} count={1} color="#ef4444" />
                        </>
                    )}
                </DiagramWrapper>
            );
        };

        const DiagramBasicAngles = ({ type }) => {
            const P = getPt(270); const A = getPt(150); const B = getPt(30);
            
            if (type === 'angle-center') {
                return (
                    <DiagramWrapper>
                        <line x1={CX} y1={CY} x2={A.x} y2={A.y} stroke="#334155" strokeWidth="2" />
                        <line x1={CX} y1={CY} x2={B.x} y2={B.y} stroke="#334155" strokeWidth="2" />
                        <line x1={P.x} y1={P.y} x2={A.x} y2={A.y} stroke="#94a3b8" strokeWidth="2" />
                        <line x1={P.x} y1={P.y} x2={B.x} y2={B.y} stroke="#94a3b8" strokeWidth="2" />
                        <AngleArc corner={{x:CX,y:CY}} startDeg={30} endDeg={150} r={25} label="2x" color="#ef4444" />
                        <AngleArc corner={P} startDeg={60} endDeg={120} r={35} label="x" color="#3b82f6" />
                    </DiagramWrapper>
                );
            }
            if (type === 'semi-circle') {
                const D1 = getPt(180); const D2 = getPt(0); const V = getPt(240);
                return (
                    <DiagramWrapper>
                        <line x1={D1.x} y1={D1.y} x2={D2.x} y2={D2.y} stroke="#334155" strokeWidth="2" />
                        <line x1={D1.x} y1={D1.y} x2={V.x} y2={V.y} stroke="#3b82f6" strokeWidth="2" />
                        <line x1={D2.x} y1={D2.y} x2={V.x} y2={V.y} stroke="#3b82f6" strokeWidth="2" />
                        <RightAngleMark p1={D1} corner={V} p2={D2} size={15} />
                    </DiagramWrapper>
                );
            }
            if (type === 'same-segment' || type === 'same-segment-converse') {
                const B1 = getPt(140); const B2 = getPt(40); 
                const A1 = getPt(220); const A2 = getPt(320);
                return (
                    <DiagramWrapper dottedCircle={type === 'same-segment-converse'}>
                        <line x1={B1.x} y1={B1.y} x2={B2.x} y2={B2.y} stroke="#94a3b8" strokeWidth="1" strokeDasharray="2" />
                        <line x1={A1.x} y1={A1.y} x2={B1.x} y2={B1.y} stroke="#334155" strokeWidth="2" />
                        <line x1={A1.x} y1={A1.y} x2={B2.x} y2={B2.y} stroke="#334155" strokeWidth="2" />
                        <line x1={A2.x} y1={A2.y} x2={B1.x} y2={B1.y} stroke="#334155" strokeWidth="2" />
                        <line x1={A2.x} y1={A2.y} x2={B2.x} y2={B2.y} stroke="#334155" strokeWidth="2" />
                        <AngleArc corner={A1} startDeg={40} endDeg={90} r={25} label="x" color="#ef4444" />
                        <AngleArc corner={A2} startDeg={90} endDeg={140} r={25} label="x" color="#ef4444" />
                    </DiagramWrapper>
                );
            }
        };

        const DiagramRelations = ({ type }) => {
            const isProp = type.startsWith('prop');
            
            const startA = isProp ? 200 : 185;
            const endA   = isProp ? 260 : 255; 
            const startC = isProp ? 300 : 285;
            const endC   = isProp ? 360 : 355; 

            const A = getPt(startA), B = getPt(endA); 
            const C = getPt(startC), D = getPt(endC); 
            
            const getArc = (s, e) => getArcPath(s, e);

            // Combined question type for Arcs/Angles/Chords: SHOW ALL (Angle, Arc, Chord)
            if (type === 'combined-equal') {
                return (
                    <DiagramWrapper>
                        <path d={getArc(startA, endA)} fill="none" stroke="#f97316" strokeWidth="4" />
                        <path d={getArc(startC, endC)} fill="none" stroke="#a855f7" strokeWidth="4" />
                        
                        <line x1={CX} y1={CY} x2={A.x} y2={A.y} stroke="#e2e8f0" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={B.x} y2={B.y} stroke="#e2e8f0" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={C.x} y2={C.y} stroke="#e2e8f0" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={D.x} y2={D.y} stroke="#e2e8f0" strokeWidth="1"/>
                        
                        <AngleArc corner={{x:CX,y:CY}} startDeg={startA} endDeg={endA} label="x" color="#f97316" />
                        <AngleArc corner={{x:CX,y:CY}} startDeg={startC} endDeg={endC} label="x" color="#a855f7" />
                        
                        <line x1={A.x} y1={A.y} x2={B.x} y2={B.y} stroke="#ef4444" strokeWidth="2"/>
                        <TickMark p1={A} p2={B} color="#ef4444" />
                        <line x1={C.x} y1={C.y} x2={D.x} y2={D.y} stroke="#ef4444" strokeWidth="2"/>
                        <TickMark p1={C} p2={D} color="#ef4444" />
                    </DiagramWrapper>
                )
            }

            // New type: Chord-Angle (No Arcs) for Q11
            if (type === 'combined-chord-angle') {
                return (
                    <DiagramWrapper>
                        {/* Radii */}
                        <line x1={CX} y1={CY} x2={A.x} y2={A.y} stroke="#e2e8f0" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={B.x} y2={B.y} stroke="#e2e8f0" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={C.x} y2={C.y} stroke="#e2e8f0" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={D.x} y2={D.y} stroke="#e2e8f0" strokeWidth="1"/>
                        
                        {/* Angles */}
                        <AngleArc corner={{x:CX,y:CY}} startDeg={startA} endDeg={endA} label="x" color="#f97316" />
                        <AngleArc corner={{x:CX,y:CY}} startDeg={startC} endDeg={endC} label="x" color="#a855f7" />
                        
                        {/* Chords */}
                        <line x1={A.x} y1={A.y} x2={B.x} y2={B.y} stroke="#ef4444" strokeWidth="2"/>
                        <TickMark p1={A} p2={B} color="#ef4444" />
                        <line x1={C.x} y1={C.y} x2={D.x} y2={D.y} stroke="#ef4444" strokeWidth="2"/>
                        <TickMark p1={C} p2={D} color="#ef4444" />
                    </DiagramWrapper>
                )
            }

            // New type for Arc-Chord relation ONLY (No angles/radii) for Q13
            if (type === 'combined-arc-chord') {
                return (
                    <DiagramWrapper>
                        <path d={getArc(startA, endA)} fill="none" stroke="#f97316" strokeWidth="4" />
                        <path d={getArc(startC, endC)} fill="none" stroke="#a855f7" strokeWidth="4" />
                        
                        <line x1={A.x} y1={A.y} x2={B.x} y2={B.y} stroke="#ef4444" strokeWidth="2"/>
                        <TickMark p1={A} p2={B} color="#ef4444" />
                        <line x1={C.x} y1={C.y} x2={D.x} y2={D.y} stroke="#ef4444" strokeWidth="2"/>
                        <TickMark p1={C} p2={D} color="#ef4444" />
                    </DiagramWrapper>
                )
            }

            // New type for Arc-Angle (No Chords) for Q9
            if (type === 'combined-arc-angle') {
                return (
                    <DiagramWrapper>
                        <path d={getArc(startA, endA)} fill="none" stroke="#f97316" strokeWidth="4" />
                        <path d={getArc(startC, endC)} fill="none" stroke="#a855f7" strokeWidth="4" />
                        
                        <line x1={CX} y1={CY} x2={A.x} y2={A.y} stroke="#e2e8f0" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={B.x} y2={B.y} stroke="#e2e8f0" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={C.x} y2={C.y} stroke="#e2e8f0" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={D.x} y2={D.y} stroke="#e2e8f0" strokeWidth="1"/>
                        
                        <AngleArc corner={{x:CX,y:CY}} startDeg={startA} endDeg={endA} label="x" color="#f97316" />
                        <AngleArc corner={{x:CX,y:CY}} startDeg={startC} endDeg={endC} label="x" color="#a855f7" />
                    </DiagramWrapper>
                )
            }

            // Proportion Center: Larger Angles (60 & 120)
            if (type === 'prop-center') {
                const pA = getPt(200); const pB = getPt(260); // 60 deg
                const pE = getPt(340); const pF = getPt(100); // 120 deg
                return (
                    <DiagramWrapper>
                        <line x1={CX} y1={CY} x2={pA.x} y2={pA.y} stroke="#cbd5e1" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={pB.x} y2={pB.y} stroke="#cbd5e1" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={pE.x} y2={pE.y} stroke="#cbd5e1" strokeWidth="1"/>
                        <line x1={CX} y1={CY} x2={pF.x} y2={pF.y} stroke="#cbd5e1" strokeWidth="1"/>
                        
                        {/* Only keeping the orange arc */}
                        <path d={getArcPath(200, 260)} fill="none" stroke="#f97316" strokeWidth="3" />
                        
                        {/* Re-added Purple Arc for 2x with CORRECT 120 deg path */}
                        <path d={getArcPath(340, 100)} fill="none" stroke="#a855f7" strokeWidth="3" />
                        
                        {/* Angle Arcs at center - MATCHING COLORS */}
                        <AngleArc corner={{x:CX,y:CY}} startDeg={200} endDeg={260} label="x" color="#f97316" r={40} />
                        <AngleArc corner={{x:CX,y:CY}} startDeg={340} endDeg={460} label="2x" color="#a855f7" r={40} />
                        
                        {/* Moved 3cm UP (y-5) */}
                        <text x={pA.x-25} y={pA.y-5} fontSize="12" fill="#f97316" fontWeight="bold">3cm</text>
                        {/* Moved 6cm Right More (+25 -> +55) to avoid covering by circle */}
                        <text x={pF.x+55} y={pF.y+5} fontSize="12" fill="#a855f7" fontWeight="bold">6cm</text>
                    </DiagramWrapper>
                )
            }
             // Proportion Circum: Larger Angles (30 & 60)
             if (type === 'prop-circum') {
                const V_top = getPt(270);
                const pA = getPt(150); const pB = getPt(210); // Arc 60 -> Angle 30
                const pE = getPt(330); const pF = getPt(90);  // Arc 120 -> Angle 60

                const degVA = getDeg(V_top, pA); const degVB = getDeg(V_top, pB);
                const degVE = getDeg(V_top, pE); const degVF = getDeg(V_top, pF);

                return (
                    <DiagramWrapper>
                        <line x1={V_top.x} y1={V_top.y} x2={pA.x} y2={pA.y} stroke="#cbd5e1" strokeWidth="1"/>
                        <line x1={V_top.x} y1={V_top.y} x2={pB.x} y2={pB.y} stroke="#cbd5e1" strokeWidth="1"/>
                        <line x1={V_top.x} y1={V_top.y} x2={pE.x} y2={pE.y} stroke="#cbd5e1" strokeWidth="1"/>
                        <line x1={V_top.x} y1={V_top.y} x2={pF.x} y2={pF.y} stroke="#cbd5e1" strokeWidth="1"/>

                        {/* Only keeping the orange arc */}
                        <path d={getArcPath(150, 210)} fill="none" stroke="#f97316" strokeWidth="3" />
                        
                        {/* Re-added Purple Arc for 2x with CORRECT path */}
                        <path d={getArcPath(330, 90)} fill="none" stroke="#a855f7" strokeWidth="3" />

                        {/* Angle Arcs at Circumference - MATCHING COLORS */}
                        <AngleArc corner={V_top} startDeg={degVB} endDeg={degVA} label="x" color="#f97316" r={50} />
                        <AngleArc corner={V_top} startDeg={degVE} endDeg={degVF} label="2x" color="#a855f7" r={50} />

                        {/* Moved 3cm UP (y+5 instead of +10) */}
                        <text x={pA.x-25} y={pA.y+5} fontSize="12" fill="#f97316" fontWeight="bold">3cm</text>
                        {/* Moved 6cm Right More (+30 -> +50) */}
                        <text x={pF.x+50} y={pF.y+5} fontSize="12" fill="#a855f7" fontWeight="bold">6cm</text>
                    </DiagramWrapper>
                )
            }
        };

        const DiagramCyclic = ({ type }) => {
            const P1 = getPt(220); // TL
            const P2 = getPt(320); // TR
            const P3 = getPt(40);  // BR
            const P4 = getPt(160); // BL
            const isConverse = type.includes('converse');
            const isExt = type.includes('ext');
            const isSupp = type === 'supp';

            if (type === 'ext-angle') { // Prop 21
                const extEnd = { x: P1.x - 40, y: P1.y };
                return (
                     <DiagramWrapper hideCircle={true}>
                         <polygon points={`${P1.x},${P1.y} ${P2.x},${P2.y} ${P3.x},${P3.y} ${P4.x},${P4.y}`} fill="rgba(59, 130, 246, 0.1)" stroke="#334155" strokeWidth="2" />
                         <line x1={P2.x} y1={P2.y} x2={extEnd.x} y2={extEnd.y} stroke="#334155" strokeWidth="2" />
                         <AngleArc corner={P1} startDeg={getDeg(P1,extEnd)} endDeg={getDeg(P1,P4)} label="x" color="#ef4444" />
                         <AngleArc corner={P3} startDeg={getDeg(P3,P4)} endDeg={getDeg(P3,P2)} label="x" color="#ef4444" />
                     </DiagramWrapper>
                );
            }
            if (type === 'cyclic-ext') {
                 const extEnd = { x: P1.x - 40, y: P1.y };
                 return (
                    <DiagramWrapper>
                         <polygon points={`${P1.x},${P1.y} ${P2.x},${P2.y} ${P3.x},${P3.y} ${P4.x},${P4.y}`} fill="rgba(59, 130, 246, 0.1)" stroke="#334155" strokeWidth="2" />
                         <line x1={P2.x} y1={P2.y} x2={extEnd.x} y2={extEnd.y} stroke="#334155" strokeWidth="2" />
                         <AngleArc corner={P1} startDeg={getDeg(P1,extEnd)} endDeg={getDeg(P1,P4)} label="x" color="#ef4444" />
                         <AngleArc corner={P3} startDeg={getDeg(P3,P4)} endDeg={getDeg(P3,P2)} label="x" color="#ef4444" />
                    </DiagramWrapper>
                 );
            }
            return (
                <DiagramWrapper dottedCircle={isConverse}>
                    <polygon points={`${P1.x},${P1.y} ${P2.x},${P2.y} ${P3.x},${P3.y} ${P4.x},${P4.y}`} fill="rgba(59, 130, 246, 0.1)" stroke="#334155" strokeWidth="2" />
                    <AngleArc corner={P1} startDeg={getDeg(P1,P2)} endDeg={getDeg(P1,P4)} label="x" color="#ef4444" />
                    <AngleArc corner={P3} startDeg={getDeg(P3,P4)} endDeg={getDeg(P3,P2)} label="y" color="#ef4444" />
                    {isSupp && <text x={100} y={195} fontSize="10" fill="#64748b" textAnchor="middle">x+y=180¬∞</text>}
                    {type === 'opp' && <text x={100} y={195} fontSize="10" fill="#64748b" textAnchor="middle">x+y=180¬∞</text>}
                </DiagramWrapper>
            );
        };

        const DiagramTangent = ({ type }) => {
            if (type === 'perp') {
                const P = getPt(0);
                return (
                    <DiagramWrapper>
                        <line x1={CX} y1={CY} x2={P.x} y2={P.y} stroke="#334155" strokeWidth="2" />
                        <line x1={P.x} y1={40} x2={P.x} y2={160} stroke="#ef4444" strokeWidth="2" />
                        <circle cx={P.x} cy={P.y} r="4" fill="#ef4444" />
                    </DiagramWrapper>
                )
            }
             if (type === 'perp-converse') {
                const P = getPt(0);
                return (
                    <DiagramWrapper>
                        <line x1={CX} y1={CY} x2={P.x} y2={P.y} stroke="#334155" strokeWidth="2" />
                        <line x1={P.x} y1={40} x2={P.x} y2={160} stroke="#ef4444" strokeWidth="2" />
                        <RightAngleMark p1={{x:CX,y:CY}} corner={P} p2={{x:P.x,y:40}} size={12} />
                    </DiagramWrapper>
                )
            }
            if (type === 'props') {
                const OT = 140; const angleDeg = (Math.acos(R/OT) * 180) / Math.PI;
                const T = { x: CX + OT, y: CY }; const P1 = getPt(-angleDeg); const P2 = getPt(angleDeg);
                return (
                    <DiagramWrapper>
                        <line x1={P1.x} y1={P1.y} x2={T.x} y2={T.y} stroke="#334155" strokeWidth="2" />
                        <line x1={P2.x} y1={P2.y} x2={T.x} y2={T.y} stroke="#334155" strokeWidth="2" />
                        <circle cx={P1.x} cy={P1.y} r="4" fill="#ef4444" />
                        <circle cx={P2.x} cy={P2.y} r="4" fill="#ef4444" />
                        <circle cx={T.x} cy={T.y} r="3" fill="#334155" />
                        <text x={T.x+5} y={T.y+5} fontSize="12" fill="#334155">T</text>
                    </DiagramWrapper>
                )
            }
            if (type === 'alt' || type === 'alt-converse') {
                const T = getPt(90); const A = getPt(210); const B = getPt(330);
                const isConverse = type === 'alt-converse';
                return (
                    <DiagramWrapper dottedCircle={isConverse}>
                        <line x1={20} y1={T.y} x2={180} y2={T.y} stroke="#ef4444" strokeWidth="2" />
                        <polygon points={`${T.x},${T.y} ${A.x},${A.y} ${B.x},${B.y}`} fill="none" stroke="#334155" strokeWidth="2" />
                        <AngleArc corner={T} startDeg={180} endDeg={getDeg(T,A)} label="x" color="#3b82f6" r={30} />
                        <AngleArc corner={B} startDeg={getDeg(B,A)} endDeg={getDeg(B,T)} label="x" color="#3b82f6" r={25} />
                    </DiagramWrapper>
                )
            }
        };

        const PROP_TEXTS = {
            1: "ÂúìÂøÉËá≥Âº¶ÁöÑÂûÇÁ∑öÂπ≥ÂàÜÂº¶\n(‚ä• from centre to chord bisects chord)",
            2: "ÂúìÂøÉËá≥Âº¶‰∏≠ÈªûÁöÑÈÄ£Á∑öÂûÇÁõ¥Âº¶\n(line joining centre and mid-pt. of chord ‚ä•chord)",
            3: "Âº¶ÁöÑÂûÇÁõ¥Âπ≥ÂàÜÁ∑öÁ©øÈÅéÂúìÂøÉ\n(‚ä•bisector of chord passes through centre)",
            4: "Á≠âÂº¶ËàáÂúìÂøÉÁ≠âË∑ù\n(eq. chords equidistant from centre)",
            5: "ËàáÂúìÂøÉÁ≠âË∑ùÁöÑÂº¶Á≠âÈï∑\n(chords equidistant from centre eq.)",
            6: "ÂúìÂøÉËßíÂÖ©ÂÄçÊñºÂúìÂë®Ëßí\n(‚à† at centre twice ‚à† at circumference)",
            7: "ÂçäÂúì‰∏äÁöÑÂúìÂë®Ëßí\n(‚à† in semi-circle)",
            8: "ÂêåÂºìÂΩ¢ÂÖßÁöÑÂúìÂë®Ëßí\n(‚à†s in the same segment)",
            9: "Á≠âÂºßÂ∞çÁ≠âËßí (equal arcs, equal ‚à†s) / Á≠âËßíÂ∞çÁ≠âÂºß (equal ‚à†s, equal arcs)",
            11: "Á≠âÂº¶Â∞çÁ≠âËßí (equal chords, equal ‚à†s) / Á≠âËßíÂ∞çÁ≠âÂº¶ (equal ‚à†s, equal chords)",
            13: "Á≠âÂºßÂ∞çÁ≠âÂº¶ (equal arcs, equal chords) / Á≠âÂº¶Â∞çÁ≠âÂºß (equal chords, equal arcs)",
            15: "ÂºßËàáÂúìÂøÉËßíÊàêÊØî‰æã\n(arcs prop. to ‚à†s at centre)",
            16: "ÂºßËàáÂúìÂë®ËßíÊàêÊØî‰æã\n(arcs prop. to ‚à†s at circumference)",
            17: "ÂúìÂÖßÊé•ÂõõÈÇäÂΩ¢Â∞çËßí\n(opp.‚à†s, cyclic quad.)",
            18: "ÂúìÂÖßÊé•ÂõõÈÇäÂΩ¢Â§ñËßí\n(ext.‚à†s, cyclic quad.)",
            19: "ÂêåÂºìÂΩ¢ÂÖßÁöÑÂúìÂë®ËßíÁöÑÈÄÜÂÆöÁêÜ\n(Converse of ‚à†s in the same segment)",
            20: "Â∞çËßí‰∫íË£ú\n(opp.‚à†s supp)",
            21: "Â§ñËßí=ÂÖßÂ∞çËßí\n(ext.‚à† = int. opp.‚à†)",
            22: "ÂàáÁ∑ö‚ä•ÂçäÂæë\n(tangent ‚ä• radius)",
            23: "ÂàáÁ∑ö‚ä•ÂçäÂæëÁöÑÈÄÜÂÆöÁêÜ\n(Converse of tangent ‚ä• radius)",
            24: "ÂàáÁ∑öÊÄßË≥™\n(tangent properties)",
            25: "ÂÖßÈåØÂºìÂΩ¢‰∏äÁöÑÂúìÂë®Ëßí\n(‚à† in alt. segment)",
            26: "ÂÖßÈåØÂºìÂΩ¢‰∏äÁöÑÂúìÂë®ËßíÁöÑÈÄÜÂÆöÁêÜ\n(Converse of ‚à† in alt. segment)"
        };

        const fullQuestionsData = [
            { id: 1, component: <DiagramChordProp type="perp-bisect" />, answer: PROP_TEXTS[1], distractors: [PROP_TEXTS[4], PROP_TEXTS[6], PROP_TEXTS[22]] },
            { id: 2, component: <DiagramChordProp type="mid-perp" />, answer: PROP_TEXTS[2], distractors: [PROP_TEXTS[5], PROP_TEXTS[7], PROP_TEXTS[23]] },
            { id: 3, component: <DiagramChordProp type="perp-bisector-center" />, answer: PROP_TEXTS[3], distractors: [PROP_TEXTS[4], PROP_TEXTS[15], PROP_TEXTS[24]] },
            { id: 4, component: <DiagramChordDist type="eq-chord-eq-dist" />, answer: PROP_TEXTS[4], distractors: [PROP_TEXTS[9], PROP_TEXTS[11], PROP_TEXTS[15]] },
            { id: 5, component: <DiagramChordDist type="eq-dist-eq-chord" />, answer: PROP_TEXTS[5], distractors: [PROP_TEXTS[9], PROP_TEXTS[11], PROP_TEXTS[16]] },
            { id: 6, component: <DiagramBasicAngles type="angle-center" />, answer: PROP_TEXTS[6], distractors: [PROP_TEXTS[7], PROP_TEXTS[8], PROP_TEXTS[15]] },
            { id: 7, component: <DiagramBasicAngles type="semi-circle" />, answer: PROP_TEXTS[7], distractors: [PROP_TEXTS[6], PROP_TEXTS[22], PROP_TEXTS[17]] },
            { id: 8, component: <DiagramBasicAngles type="same-segment" />, answer: PROP_TEXTS[8], distractors: [PROP_TEXTS[6], PROP_TEXTS[9], PROP_TEXTS[25]] },
            // Combined Questions 9, 11, 13
            { id: 9, component: <DiagramRelations type="combined-arc-angle" />, answer: PROP_TEXTS[9], distractors: [PROP_TEXTS[11], PROP_TEXTS[13], PROP_TEXTS[15]] },
            { id: 11, component: <DiagramRelations type="combined-chord-angle" />, answer: PROP_TEXTS[11], distractors: [PROP_TEXTS[9], PROP_TEXTS[13], PROP_TEXTS[4]] },
            // Q13 use combined-arc-chord
            { id: 13, component: <DiagramRelations type="combined-arc-chord" />, answer: PROP_TEXTS[13], distractors: [PROP_TEXTS[9], PROP_TEXTS[11], PROP_TEXTS[4]] },
            
            { id: 15, component: <DiagramRelations type="prop-center" />, answer: PROP_TEXTS[15], distractors: [PROP_TEXTS[9], PROP_TEXTS[16], PROP_TEXTS[6]] },
            { id: 16, component: <DiagramRelations type="prop-circum" />, answer: PROP_TEXTS[16], distractors: [PROP_TEXTS[9], PROP_TEXTS[15], PROP_TEXTS[8]] },
            { id: 17, component: <DiagramCyclic type="opp" />, answer: PROP_TEXTS[17], distractors: [PROP_TEXTS[8], PROP_TEXTS[18], PROP_TEXTS[25]] },
            { id: 18, component: <DiagramCyclic type="cyclic-ext" />, answer: PROP_TEXTS[18], distractors: [PROP_TEXTS[25], PROP_TEXTS[17], PROP_TEXTS[15]] },
            { id: 19, component: <DiagramBasicAngles type="same-segment-converse" />, answer: PROP_TEXTS[19], distractors: [PROP_TEXTS[20], PROP_TEXTS[21], PROP_TEXTS[23]] },
            { id: 20, component: <DiagramCyclic type="opp" />, answer: PROP_TEXTS[20], distractors: [PROP_TEXTS[19], PROP_TEXTS[21], PROP_TEXTS[26]] },
            { id: 21, component: <DiagramCyclic type="ext-angle" />, answer: PROP_TEXTS[21], distractors: [PROP_TEXTS[19], PROP_TEXTS[20], PROP_TEXTS[24]] },
            { id: 22, component: <DiagramTangent type="perp" />, answer: PROP_TEXTS[22], distractors: [PROP_TEXTS[1], PROP_TEXTS[7], PROP_TEXTS[24]] },
            { id: 23, component: <DiagramTangent type="perp-converse" />, answer: PROP_TEXTS[23], distractors: [PROP_TEXTS[2], PROP_TEXTS[3], PROP_TEXTS[26]] },
            { id: 24, component: <DiagramTangent type="props" />, answer: PROP_TEXTS[24], distractors: [PROP_TEXTS[4], PROP_TEXTS[22], PROP_TEXTS[25]] },
            { id: 25, component: <DiagramTangent type="alt" />, answer: PROP_TEXTS[25], distractors: [PROP_TEXTS[8], PROP_TEXTS[18], PROP_TEXTS[24]] },
            { id: 26, component: <DiagramTangent type="alt-converse" />, answer: PROP_TEXTS[26], distractors: [PROP_TEXTS[19], PROP_TEXTS[21], PROP_TEXTS[23]] },
        ];

        const shuffleArray = (array) => {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        };

        const App = () => {
            const [gameState, setGameState] = useState('start'); 
            const [currentQIndex, setCurrentQIndex] = useState(0);
            // score derived from userAnswers
            
            const [activeQuestions, setActiveQuestions] = useState([]);
            const [userAnswers, setUserAnswers] = useState({}); // { index: { options, selected, isCorrect } }
            const [currentOptions, setCurrentOptions] = useState([]);
            const [selectedOption, setSelectedOption] = useState(null);
            const [isCorrect, setIsCorrect] = useState(null);

            const score = useMemo(() => {
                return Object.values(userAnswers).filter(a => a && a.isCorrect).length;
            }, [userAnswers]);

            const startGame = () => {
                const shuffledFull = shuffleArray(fullQuestionsData);
                setActiveQuestions(shuffledFull);
                
                // Init first question
                const q0 = shuffledFull[0];
                const options0 = shuffleArray([q0.answer, ...q0.distractors]);
                
                setUserAnswers({ 0: { options: options0, selected: null, isCorrect: null } });
                setCurrentOptions(options0);
                setSelectedOption(null);
                setIsCorrect(null);
                
                setCurrentQIndex(0);
                setGameState('playing');
            };

            const loadQuestion = (index) => {
                // If we have visited this question before (or it's the current one), load state
                if (userAnswers[index]) {
                    const saved = userAnswers[index];
                    setCurrentOptions(saved.options);
                    setSelectedOption(saved.selected);
                    setIsCorrect(saved.isCorrect);
                } else {
                    // New question we haven't seen in this session yet
                    const q = activeQuestions[index];
                    const options = shuffleArray([q.answer, ...q.distractors]);
                    
                    setCurrentOptions(options);
                    setSelectedOption(null);
                    setIsCorrect(null);
                    
                    // Initial save
                    setUserAnswers(prev => ({
                        ...prev,
                        [index]: { options, selected: null, isCorrect: null }
                    }));
                }
                setCurrentQIndex(index);
            };

            const handleOptionClick = (option) => {
                // If already answered, don't allow changing (standard quiz behavior)? 
                // Or allow changing? Let's allow changing since "Previous" implies review/edit potential.
                // But typically for "training" quizzes, immediate feedback locks the answer.
                // Given the visual feedback (Green/Red), it implies locking.
                if (selectedOption) return;

                const correct = option === activeQuestions[currentQIndex].answer;
                setSelectedOption(option);
                setIsCorrect(correct);
                
                // Save to history
                setUserAnswers(prev => ({
                    ...prev,
                    [currentQIndex]: { 
                        options: currentOptions, 
                        selected: option, 
                        isCorrect: correct 
                    }
                }));
            };

            const nextQuestion = () => {
                if (currentQIndex < activeQuestions.length - 1) {
                    loadQuestion(currentQIndex + 1);
                } else {
                    setGameState('result');
                }
            };
            
            const prevQuestion = () => {
                if (currentQIndex > 0) {
                    loadQuestion(currentQIndex - 1);
                }
            };

            if (gameState === 'start') {
                return (
                    <div className="min-h-screen flex flex-col items-center justify-center p-4">
                        <div className="bg-white p-8 rounded-2xl shadow-xl max-w-md w-full text-center border-t-4 border-blue-500">
                            <h1 className="text-2xl font-bold text-slate-800 mb-2">ÂúìÁöÑÂü∫Êú¨ÊÄßË≥™Â∞èÊ∏¨È©ó</h1>
                            <h2 className="text-lg text-slate-500 mb-6">Basic Properties of Circles Quiz</h2>
                            <div className="text-left bg-slate-50 p-4 rounded-lg mb-6 text-sm text-slate-600">
                                <p className="mb-2">üìã Á∏ΩÈ°åÂ∫´Ôºö23 ÂÄãÂπæ‰ΩïÊÄßË≥™</p>
                                <p>üé≤ Ê®°ÂºèÔºöÂÆåÊï¥ÊåëÊà∞</p>
                            </div>
                            <button onClick={startGame} className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-6 rounded-xl shadow-lg transition-transform hover:scale-105">ÈñãÂßãÊ∏¨È©ó Start Quiz</button>
                        </div>
                    </div>
                );
            }

            if (gameState === 'result') {
                const percentage = Math.round((score / activeQuestions.length) * 100);
                return (
                    <div className="min-h-screen flex flex-col items-center justify-center p-4">
                        <div className="bg-white p-8 rounded-2xl shadow-xl max-w-md w-full text-center">
                            <h2 className="text-3xl font-bold text-slate-800 mb-2">{score} / {activeQuestions.length}</h2>
                            <p className="text-slate-500 mb-6 text-lg">{percentage >= 60 ? "ÂÅöÂæóÂ•ΩÔºÅWell done!" : "ÂÜçÊé•ÂÜçÂé≤ÔºÅKeep trying!"}</p>
                            <button onClick={startGame} className="w-full bg-slate-800 hover:bg-slate-900 text-white font-bold py-3 px-6 rounded-xl">ÂÜçË©¶‰∏ÄÊ¨° Try Again</button>
                        </div>
                    </div>
                );
            }

            const currentQ = activeQuestions[currentQIndex];

            return (
                <div className="min-h-screen flex flex-col items-center py-6 px-4 max-w-2xl mx-auto">
                    <div className="w-full flex justify-between items-center mb-6 px-2">
                        <div className="text-slate-500 font-medium">Question {currentQIndex + 1} / {activeQuestions.length}</div>
                        <div className="text-blue-600 font-bold bg-blue-50 px-3 py-1 rounded-full">Score: {score}</div>
                    </div>
                    <div className="bg-white rounded-2xl shadow-lg p-6 w-full mb-6 border-b-4 border-slate-200">
                        <h3 className="text-center text-slate-700 font-medium mb-4">ËßÄÂØü‰∏ãÂúñÂ∑≤Áü•Ê¢ù‰ª∂ÔºåÈÄôÊòØÂì™‰∏ÄÂÄãÂπæ‰ΩïÊÄßË≥™Ôºü<br/>Observe the given condition in the diagram, which geometric property is this?</h3>
                        <div className="diagram-container">{currentQ.component}</div>
                    </div>
                    <div className="grid grid-cols-1 gap-3 w-full">
                        {currentOptions.map((option, idx) => {
                            let btnClass = "bg-white border-2 border-slate-200 text-slate-700 hover:border-blue-400 hover:bg-blue-50";
                            let icon = null;
                            if (selectedOption) {
                                if (option === currentQ.answer) {
                                    btnClass = "bg-green-100 border-2 border-green-500 text-green-800";
                                    icon = <span className="text-green-600">‚úì</span>;
                                } else if (option === selectedOption && !isCorrect) {
                                    btnClass = "bg-red-100 border-2 border-red-500 text-red-800";
                                    icon = <span className="text-red-600">‚úï</span>;
                                } else {
                                    btnClass = "bg-slate-50 border-2 border-slate-100 text-slate-400 opacity-60";
                                }
                            }
                            return (
                                <button key={idx} onClick={() => handleOptionClick(option)} disabled={selectedOption !== null} className={`relative p-4 rounded-xl text-left transition-all duration-200 font-medium shadow-sm flex items-center justify-between ${btnClass}`}>
                                    <span className="whitespace-pre-line leading-tight text-sm">{option}</span>
                                    {icon && <div className="ml-2 text-xl font-bold">{icon}</div>}
                                </button>
                            );
                        })}
                    </div>
                    
                    {/* Navigation Buttons */}
                    <div className="w-full mt-6 flex gap-3">
                        {currentQIndex > 0 && (
                            <button 
                                onClick={prevQuestion}
                                className="flex-1 bg-slate-500 hover:bg-slate-600 text-white font-bold py-4 px-6 rounded-xl shadow-lg flex items-center justify-center gap-2 text-lg"
                            >
                                <span>‚Üê</span> ‰∏ä‰∏ÄÈ°å Previous
                            </button>
                        )}
                        
                        {selectedOption && (
                            <button 
                                onClick={nextQuestion}
                                className="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 px-6 rounded-xl shadow-lg flex items-center justify-center gap-2 text-lg"
                            >
                                {currentQIndex < activeQuestions.length - 1 ? "‰∏ã‰∏ÄÈ°å Next" : "Êü•ÁúãÁµêÊûú Results"}
                                <span>‚Üí</span>
                            </button>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        setTimeout(() => lucide.createIcons(), 100);
    </script>
</body>
</html>